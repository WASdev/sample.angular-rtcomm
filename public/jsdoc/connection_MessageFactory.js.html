<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: connection/MessageFactory.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: connection/MessageFactory.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright 2014 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/ 
/** @class
 * @memberof module:rtcomm.connector
 * @private
 */
/* Constructor */

var MessageFactory = (function (){
  // base Template used for everything.
  var _baseHeaders = {
      'rtcommVer': 'v1.0.0',
       'method' : null,
       'fromTopic': null
  };
  
  var _optionalHeaders = {
      'sigSessID':null,
      'transID':null,
      'reason': null,
      'toEndpointID': null,
      'appContext': null,
      'holdTimeout': null,
      'queuePosition': null
  };
  
  // Override base headers and add new headers for the OUTBOUND message
  // If it is a transaction, it will have a transID
  
  var _messageTemplates = {
      'SERVICE_QUERY' : {
        'method': 'SERVICE_QUERY',
        'transID': null,
      },
      'START_SESSION' : {
        'method': 'START_SESSION',
        'protocols': [],
        'sigSessID':null,
        'transID':null,
        'toEndpointID': null,
        'payload': null,
      },
      'REFER' : {
        'method': 'REFER',
        'transID':null,
        'toEndpointID': null,
        'details': null,
      },
     'STOP_SESSION' : {
        'method': 'STOP_SESSION',
        'sigSessID':null,
        'payload': null,
      },
      'PRANSWER': {
        'method': 'PRANSWER',
        'protocols': [],
        'payload': null
      },
      // Message is generic and could be anything... 
      'MESSAGE':{
        'method':'MESSAGE',
        'payload': null
      },
      'DOCUMENT': {
        'method': 'DOCUMENT',
        'type': 'ENDPOINT',
        'addressTopic':null,
        'appContext':null,
        'state': null,
        'alias': null,
        'userDefines':[]
      },
      'DOCUMENT_REPLACED': {
        'method': 'DOCUMENT_REPLACED'
      }
  };
  
  var _baseResponseTemplate = {
      'RESPONSE' : {
        'method': 'RESPONSE',
        'orig': null,
        'transID': null,
        'result': null,
      }
  };
  
  var _responseTemplates = {
      'SERVICE_QUERY' : {
        'orig': 'SERVICE_QUERY',
        'services':null
      },
      'START_SESSION' : {
        'orig': 'START_SESSION',
        'protocols': [],
        'sigSessID': null,
        'result': null,
        'payload': null,
        'transID': null,
      },
      'REFER' : {
        'orig': 'REFER',
        'transID':null,
        'result': null,
      }
  };
  
  function getMessageTemplate(type) {
    var template = {};
    objMerge(template,_baseHeaders);
    if (_messageTemplates.hasOwnProperty(type)) {
      objMerge(template,_messageTemplates[type]);
      return template;
    } else {
      console.error('Message Type: '+type+' Not found!');
      return null;
    }
  }
  
  function getResponseTemplate(type) {
    var template = {};
    objMerge(template,_baseHeaders);
    objMerge(template, _baseResponseTemplate.RESPONSE);
    if (_responseTemplates.hasOwnProperty(type)) {
      objMerge(template,_responseTemplates[type]);
      return template;
    } else {
      console.error('Message Type: '+type+' Not found!');
      return null;
    }
  }
  
  function objMerge(obj1,obj2) {
    // Take Right Object and place on top of left object.  
    for (var key in obj2) {
      if (obj2.hasOwnProperty(key)) {
        obj1[key] = obj2[key];
      }
    }
  }
  
  var SigMessage = function SigMessage(template) {
    if (template) {
      for (var key in template) {
        if (template.hasOwnProperty(key)) {
          this[key] = template[key];
        }
      }
    }
  };

  SigMessage.prototype = {
      /** Convert message to a specific JSON object 
       * 
       * @returns {JSON} 
       * 
       */
      toJSON: function() {
        var obj = {};
        for (var key in this) {
          if (this.hasOwnProperty(key)) {
            obj[key] = this[key];
          }
        }
        return obj;
      }, 
      /* Override */
      toString: function() {
        // When converted to a string, we return a SPECIFIC object content that matches the Message Template 
        return JSON.stringify(this.toJSON());
      }
  };
  
  function createResponse(type) {
    var message = null;
    var template = getResponseTemplate(type);
    if (template) {
      message = new SigMessage(template);
    } else {
      throw new TypeError('Invalid Message type:'+type+', should be one of: '+ Object.keys(_messageTemplates));
    }
    return message;
  }
  
  function createMessage(type) {
    type = type || 'MESSAGE';
    var message = null;
    var template = getMessageTemplate(type);
    if (template) {
      message = new SigMessage(template);
    } else {
      throw new TypeError('Invalid Message type:'+type+', should be one of: '+ Object.keys(_messageTemplates));
    }
    return message;
  }
  
  function isValid(message) {
    try {
      var tmpmsg = cast(message);
    } catch(e) {
      // unable to cast, not a good message.
      return false;
    }
    return true;
  }
  
  function cast(obj) {
    /*global l:false*/
    l('TRACE') &amp;&amp; console.log('MessageFactory.cast() Attempting to cast message: ', obj);
  
    if ( typeof obj === 'string') {
      l('TRACE') &amp;&amp; console.log('MessageFactory.cast() It is a string... ', obj);
      /* if its a 'STRING' then convert to a object */
      try {
        obj = JSON.parse(obj);
      } catch (e) {
        throw new TypeError('Unable to cast object as a SigMessage');
      }
      l('TRACE') &amp;&amp; console.log('MessageFactory.cast() After JSON.parse... ', obj);
    }
    var template = null;
    if (obj.method) {
      template = (obj.method === 'RESPONSE') ? getResponseTemplate(obj.orig):getMessageTemplate(obj.method);
    } else {
      throw new TypeError('Unable to cast object as a SigMessage');
    }
    var castedMessage = new SigMessage(template);
    for (var prop in obj){
      // console.log("key:" + prop + " = " + obj[prop]);
      if (template.hasOwnProperty(prop) || _optionalHeaders.hasOwnProperty(prop)){
        //    console.log("key:" + prop + " = " + obj[prop]);
        castedMessage[prop] = obj[prop];
      } else {
        l('DEBUG') &amp;&amp; console.log('MessageFactory.cast() dropped header: '+prop);
      }
    }  
    l('TRACE') &amp;&amp; console.log('MessageFactory.cast() returning casted message:', castedMessage);
    return castedMessage;
  }

  return {
    createMessage:  createMessage,
    createResponse: createResponse,
    cast : cast
  };
})();

exports.MessageFactory = MessageFactory;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-rtcomm.html">rtcomm</a></li></ul><h3>Classes</h3><ul><li><a href="module-rtcomm.EndpointProvider.html">EndpointProvider</a></li><li><a href="module-rtcomm.MqttEndpoint.html">MqttEndpoint</a></li><li><a href="module-rtcomm.PresenceMonitor.html">PresenceMonitor</a></li><li><a href="module-rtcomm.PresenceMonitor.PresenceNode.html">PresenceNode</a></li><li><a href="module-rtcomm.RtcommEndpoint.html">RtcommEndpoint</a></li><li><a href="module-rtcomm.RtcommEndpoint.Chat.html">Chat</a></li><li><a href="module-rtcomm.RtcommEndpoint.WebRTCConnection.html">WebRTCConnection</a></li><li><a href="module-rtcomm.util.RtcommBaseObject.html">RtcommBaseObject</a></li></ul><h3>Events</h3><ul><li><a href="module-rtcomm.EndpointProvider.html#event:newendpoint">newendpoint</a></li><li><a href="module-rtcomm.EndpointProvider.html#event:presence_updated">presence_updated</a></li><li><a href="module-rtcomm.EndpointProvider.html#event:queueupdate">queueupdate</a></li><li><a href="module-rtcomm.EndpointProvider.html#event:reset">reset</a></li><li><a href="module-rtcomm.PresenceMonitor.html#event:updated">updated</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:chat:connected">chat:connected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:chat:disconnected">chat:disconnected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:chat:message">chat:message</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:destroyed">destroyed</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:onetimemessage">onetimemessage</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:alerting">session:alerting</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:failed">session:failed</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:queued">session:queued</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:refer">session:refer</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:ringing">session:ringing</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:started">session:started</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:stopped">session:stopped</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:webrtc:connected">webrtc:connected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:webrtc:disconnected">webrtc:disconnected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:webrtc:failed">webrtc:failed</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:webrtc:remotemuted">webrtc:remotemuted</a></li></ul><h3>Global</h3><ul><li><a href="global.html#applyConfig">applyConfig</a></li><li><a href="global.html#generateRandomBytes">generateRandomBytes</a></li><li><a href="global.html#validateConfig">validateConfig</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Tue Jan 05 2016 10:19:37 GMT-0700 (MST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
