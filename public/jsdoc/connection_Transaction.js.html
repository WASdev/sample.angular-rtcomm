<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: connection/Transaction.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: connection/Transaction.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright 2014 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/ 
/**
   * @class
   * @memberof module:rtcomm.connector
   *
   * @classdesc
   * A Transaction is a conversation that requires a response.
   * /**
   * @param options   message: message, timeout: timeout
   * @param {callback} cbSuccess called when transaction is successful 
   * @param {callback} cbFailure 
   * 
   * @event finished Emitted when complete... can also use onSuccess.
   * @event message 
   * 
   * 
   * @private
   */
var Transaction = function Transaction(options, cbSuccess, cbFailure) {
  var message, timeout, toTopic;

  this.defaultTimeout = 5000;
  if (options) {
    message = options.message || null;
    timeout = options.timeout || null;
    toTopic = options.toTopic || null;
  }
  /* Instance Properties */
  this.objName = "Transaction";
  this.events = {'message': [],
      'timeout_changed':[],
      'canceled':[],
      'finished':[]};
  this.timeout = timeout || this.defaultTimeout;
  this.outbound = (message &amp;&amp; message.transID) ? false : true;
  /*global generateUUID:false*/
  this.id = (message &amp;&amp; message.transID) ? message.transID : generateUUID(); 
  this.method = (message &amp;&amp; message.method) ? message.method : 'UNKNOWN'; 

  this.toTopic = toTopic || ((message &amp;&amp; message.fromTopic) ? message.fromTopic : null);
  this.message = message;
  this.onSuccess = cbSuccess || function(object) {
    l('DEBUG') &amp;&amp; console.log(this+' Response for Transaction received, requires callback for more information:', object);
  };
  this.onFailure = cbFailure || function(object) {
    l('DEBUG') &amp;&amp; console.log(this+' Transaction failed, requires callback for more information:', object);
  };

  l('DEBUG') &amp;&amp; console.log(this+ '.constructor Are we outbound?', this.outbound);
};
/*global util:false*/
Transaction.prototype = util.RtcommBaseObject.extend(
   /** @lends module:rtcomm.connector.Transaction.prototype */
    {
  /*
   *  A Transaction is something that may require a response, but CAN receive messages w/ the same transaction ID 
   *  until the RESPONSE is received closing the transaction. 
   *  
   *  The types of transactions correlate with the types of Messages with the Session being the most complicated.
   *  
   *  Transaction management... 
   *  
   *  TODO:  Inbound Starts... 
   *  
   *  
   */
  /*
   * Instance Methods
   */
  setTimeout: function(timeout)  {
    this.timeout = timeout || this.defaultTimeout;
    this.emit('timeout_changed', this.timeout);
  },
 
  getInbound: function() {
    return !(this.outbound);
  },
  /**
   * Start a transaction
   * @param [timeout] can set a timeout for the transaction
   */
  start: function(timeout) {
    /*global l:false*/
    l('TRACE') &amp;&amp; console.log(this+'.start() Starting Transaction for ID: '+this.id);
    if (this.outbound) {
      this.message.transID = this.id;
      this.send(this.message);  
    } else {
      l('TRACE') &amp;&amp; console.log(this+'.start() Inbound Transaction ');
    }
  },
  /**
   * send a message over the transaction
   */
  send: function(message) {
    l('TRACE') &amp;&amp; console.log(this+'.send() sending message: '+message);
    if(message) {
      message.transID = message.transID || this.id;
      l('DEBUG') &amp;&amp; console.log('Transaction.send() ids...'+message.transID +' this.id '+ this.id+'toTopic: '+this.toTopic);
      if (message.transID === this.id) {
        this.endpointconnector.send({message: message, toTopic:this.toTopic});
      } else {
        l('DEBUG') &amp;&amp; console.log(this+'.send() Message is not part of our tranaction, dropping!', message);
      }
    } else {
      console.error('Transaction.send() requires a message to be passed');
    }
  },
  /**
   * Finish the transaction, message should be a RESPONSE.
   */
  finish: function(rtcommMessage) {
    // Is this message for THIS transaction?
    l('DEBUG') &amp;&amp; console.log(this+'.finish() Finishing transction with message:',rtcommMessage);
    // if there isn't an id here, add it. 
    rtcommMessage.transID = rtcommMessage.transID || this.id;
    if (this.id === rtcommMessage.transID &amp;&amp;
        rtcommMessage.method === 'RESPONSE' &amp;&amp; 
        this.method === rtcommMessage.orig) {
      if (this.outbound) {
        if (rtcommMessage.result  === 'SUCCESS' &amp;&amp; this.onSuccess ) {
          this.onSuccess(rtcommMessage);
        } else if (rtcommMessage.result === 'FAILURE' &amp;&amp; this.onFailure) {
          this.onFailure(rtcommMessage);
        } else {
          console.error('Unknown result for RESPONSE:', rtcommMessage);
        }
      } else {
     // If we are inbound, then send the message we have and finish the transaction
        this.send(rtcommMessage);
      }
      this.emit('finished');
    } else {
      console.error('Message not for this transaction: ', rtcommMessage);
    }
  },
  cancel: function() {
    this.emit('canceled');
  }
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-rtcomm.html">rtcomm</a></li></ul><h3>Classes</h3><ul><li><a href="module-rtcomm.EndpointProvider.html">EndpointProvider</a></li><li><a href="module-rtcomm.MqttEndpoint.html">MqttEndpoint</a></li><li><a href="module-rtcomm.PresenceMonitor.html">PresenceMonitor</a></li><li><a href="module-rtcomm.PresenceMonitor.PresenceNode.html">PresenceNode</a></li><li><a href="module-rtcomm.RtcommEndpoint.html">RtcommEndpoint</a></li><li><a href="module-rtcomm.RtcommEndpoint.Chat.html">Chat</a></li><li><a href="module-rtcomm.RtcommEndpoint.WebRTCConnection.html">WebRTCConnection</a></li><li><a href="module-rtcomm.util.RtcommBaseObject.html">RtcommBaseObject</a></li></ul><h3>Events</h3><ul><li><a href="module-rtcomm.EndpointProvider.html#event:newendpoint">newendpoint</a></li><li><a href="module-rtcomm.EndpointProvider.html#event:presence_updated">presence_updated</a></li><li><a href="module-rtcomm.EndpointProvider.html#event:queueupdate">queueupdate</a></li><li><a href="module-rtcomm.EndpointProvider.html#event:reset">reset</a></li><li><a href="module-rtcomm.PresenceMonitor.html#event:updated">updated</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:chat:connected">chat:connected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:chat:disconnected">chat:disconnected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:chat:message">chat:message</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:destroyed">destroyed</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:onetimemessage">onetimemessage</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:alerting">session:alerting</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:failed">session:failed</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:queued">session:queued</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:refer">session:refer</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:ringing">session:ringing</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:started">session:started</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:session:stopped">session:stopped</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:webrtc:connected">webrtc:connected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:webrtc:disconnected">webrtc:disconnected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:webrtc:failed">webrtc:failed</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:webrtc:remotemuted">webrtc:remotemuted</a></li></ul><h3>Global</h3><ul><li><a href="global.html#applyConfig">applyConfig</a></li><li><a href="global.html#generateRandomBytes">generateRandomBytes</a></li><li><a href="global.html#validateConfig">validateConfig</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Tue Jan 05 2016 10:19:37 GMT-0700 (MST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
